// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2025-2026 natyamatsya contributors
//
// Rust 2024 edition service process — demonstrates that process separation
// allows each component to use a *different language entirely*.
//
// The C++ host spawns this binary exactly like the C++ or C++23 service.
// Communication happens through the same proto primitives (shm_ring,
// service_registry, shared_state) via a thin C FFI layer.
//
// All FFI types and function signatures are auto-generated by bindgen from
// rt_audio_ffi.h — no hand-written struct layouts or extern declarations.

use std::sync::atomic::{AtomicBool, Ordering};
use std::time::{Duration, Instant};

// ---------------------------------------------------------------------------
// Auto-generated FFI bindings from rt_audio_ffi.h (via bindgen)
// ---------------------------------------------------------------------------

#[allow(non_upper_case_globals)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(dead_code)]
mod ffi {
    include!(concat!(env!("OUT_DIR"), "/ffi_bindings.rs"));
}

use ffi::rt_ffi_audio_block as AudioBlock;

// ---------------------------------------------------------------------------
// Safe wrappers over bindgen-generated FFI
// ---------------------------------------------------------------------------

/// Opaque handle (bindgen maps `void*` to `*mut c_void`).
type Handle = *mut std::ffi::c_void;

/// Null-terminated C string helper.
fn cstr(s: &str) -> std::ffi::CString {
    std::ffi::CString::new(s).expect("CString::new failed")
}

struct SharedState(Handle);
impl SharedState {
    fn open(name: &str) -> Option<Self> {
        let p = unsafe { ffi::rt_ffi_shared_state_open(cstr(name).as_ptr()) };
        if p.is_null() { None } else { Some(Self(p)) }
    }
    fn sample_rate(&self) -> u32 { unsafe { ffi::rt_ffi_state_sample_rate(self.0) } }
    fn channels(&self) -> u32 { unsafe { ffi::rt_ffi_state_channels(self.0) } }
    fn frames_per_buffer(&self) -> u32 { unsafe { ffi::rt_ffi_state_frames_per_buffer(self.0) } }
    fn stream_active(&self) -> bool { unsafe { ffi::rt_ffi_state_stream_active(self.0) } }
    fn gain(&self) -> f32 { unsafe { ffi::rt_ffi_state_gain(self.0) } }
    fn pan(&self) -> f32 { unsafe { ffi::rt_ffi_state_pan(self.0) } }
    fn add_blocks_produced(&self, n: u64) { unsafe { ffi::rt_ffi_state_add_blocks_produced(self.0, n) } }
    fn touch_heartbeat(&self) { unsafe { ffi::rt_ffi_state_touch_heartbeat(self.0) } }
}
impl Drop for SharedState {
    fn drop(&mut self) { unsafe { ffi::rt_ffi_shared_state_close(self.0) } }
}

struct Ring(Handle);
impl Ring {
    fn open(name: &str) -> Option<Self> {
        let p = unsafe { ffi::rt_ffi_ring_open(cstr(name).as_ptr()) };
        if p.is_null() { None } else { Some(Self(p)) }
    }
    fn write_overwrite(&self, blk: &AudioBlock) {
        unsafe { ffi::rt_ffi_ring_write_overwrite(self.0, blk as *const _) }
    }
}
impl Drop for Ring {
    fn drop(&mut self) { unsafe { ffi::rt_ffi_ring_close(self.0) } }
}

struct Registry(Handle);
impl Registry {
    fn open(domain: &str) -> Option<Self> {
        let p = unsafe { ffi::rt_ffi_registry_open(cstr(domain).as_ptr()) };
        if p.is_null() { None } else { Some(Self(p)) }
    }
    fn register_service(&self, name: &str, ctrl: &str, reply: &str) -> bool {
        unsafe {
            ffi::rt_ffi_registry_register(self.0, cstr(name).as_ptr(),
                                          cstr(ctrl).as_ptr(), cstr(reply).as_ptr())
        }
    }
    fn unregister_service(&self, name: &str) -> bool {
        unsafe { ffi::rt_ffi_registry_unregister(self.0, cstr(name).as_ptr()) }
    }
}
impl Drop for Registry {
    fn drop(&mut self) { unsafe { ffi::rt_ffi_registry_close(self.0) } }
}

// ---------------------------------------------------------------------------
// Signal handling
// ---------------------------------------------------------------------------

static RUNNING: AtomicBool = AtomicBool::new(true);

extern "C" fn signal_handler(_sig: i32) {
    RUNNING.store(false, Ordering::Relaxed);
}

// ---------------------------------------------------------------------------
// Audio rendering
// ---------------------------------------------------------------------------

fn render_audio(blk: &mut AudioBlock, seq: u64, state: &SharedState) {
    blk.sequence = seq;
    blk.sample_rate = state.sample_rate();
    blk.channels = state.channels();
    blk.frames = state.frames_per_buffer();

    let gain = state.gain();
    let pan = state.pan();
    let l_gain = gain * (1.0 - pan) * 0.5;
    let r_gain = gain * (1.0 + pan) * 0.5;

    const FREQ: f32 = 440.0;
    let two_pi: f32 = 2.0 * std::f32::consts::PI;
    let sr = blk.sample_rate as f32;

    for f in 0..blk.frames {
        let t = (seq * blk.frames as u64 + f as u64) as f32 / sr;
        let s = (two_pi * FREQ * t).sin();
        let ch = blk.channels as usize;
        let base = f as usize * ch;
        if ch >= 1 { blk.samples[base] = s * l_gain; }
        if ch >= 2 { blk.samples[base + 1] = s * r_gain; }
    }
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

fn main() {
    // Install signal handlers
    unsafe {
        libc_signal(2, signal_handler);  // SIGINT
        libc_signal(15, signal_handler); // SIGTERM
    }

    let args: Vec<String> = std::env::args().collect();
    let instance_id = args.get(1).map(|s| s.as_str()).unwrap_or("");

    let (svc_name, ring_name, state_name) = if instance_id.is_empty() {
        ("rt_audio".to_string(), "rt_audio_ring".to_string(), "rt_audio_state".to_string())
    } else {
        (format!("rt_audio.{instance_id}"),
         format!("rt_audio_ring_{instance_id}"),
         format!("rt_audio_state_{instance_id}"))
    };

    let pid = unsafe { ffi::rt_ffi_getpid() };
    println!("rt_service_rs[{svc_name}]: starting (pid={pid})");

    // Open shared state
    let state = SharedState::open(&state_name)
        .unwrap_or_else(|| {
            eprintln!("rt_service_rs[{svc_name}]: failed to open shared state '{state_name}'");
            std::process::exit(1);
        });

    // Open ring buffer
    let ring = Ring::open(&ring_name)
        .unwrap_or_else(|| {
            eprintln!("rt_service_rs[{svc_name}]: failed to open ring buffer '{ring_name}'");
            std::process::exit(1);
        });

    // Register in the service registry
    let registry = Registry::open("audio_rt")
        .unwrap_or_else(|| {
            eprintln!("rt_service_rs[{svc_name}]: failed to open registry");
            std::process::exit(1);
        });
    registry.register_service(&svc_name, &ring_name, &state_name);
    println!("rt_service_rs[{svc_name}]: registered (ring={ring_name} state={state_name})");

    // Set real-time thread priority
    let (sr, fpb) = (48000u32, 256u32);
    let period = unsafe { ffi::rt_ffi_audio_period_ns(sr, fpb) };
    if unsafe { ffi::rt_ffi_set_realtime_priority(period) } {
        println!("rt_service_rs[{svc_name}]: real-time priority set (period={period} ns)");
    } else {
        println!("rt_service_rs[{svc_name}]: running without RT priority");
    }

    // Render loop
    let mut seq: u64 = 0;
    let mut next_wake = Instant::now();

    println!("rt_service_rs[{svc_name}]: entering render loop");

    while RUNNING.load(Ordering::Relaxed) {
        if !state.stream_active() {
            std::thread::sleep(Duration::from_millis(10));
            state.touch_heartbeat();
            continue;
        }

        let cur_sr = state.sample_rate();
        let cur_fpb = state.frames_per_buffer();
        if cur_sr == 0 || cur_fpb == 0 {
            std::thread::sleep(Duration::from_millis(1));
            continue;
        }
        let callback_period = Duration::from_nanos(
            cur_fpb as u64 * 1_000_000_000 / cur_sr as u64,
        );

        let mut blk = AudioBlock::default();
        render_audio(&mut blk, seq, &state);
        ring.write_overwrite(&blk);
        seq += 1;

        state.add_blocks_produced(1);
        state.touch_heartbeat();

        next_wake += callback_period;
        let now = Instant::now();
        if next_wake > now {
            std::thread::sleep(next_wake - now);
        } else {
            next_wake = now;
        }
    }

    println!("rt_service_rs[{svc_name}]: shutting down");
    registry.unregister_service(&svc_name);
}

// Minimal signal() binding — avoids pulling in the `libc` crate dependency.
unsafe extern "C" {
    #[link_name = "signal"]
    fn libc_signal(sig: i32, handler: extern "C" fn(i32)) -> usize;
}
